<!DOCTYPE html>
<html>
<head>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.24.1/dist/phaser.min.js"></script>
</head>
<body>

    <script>

    const config = {
        type: Phaser.AUTO,
        width: 1024,
        height: 510,
        physics: {
            default: 'arcade',
            arcade: {
                gravity: { y: 200 }
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        },
    };

    const game = new Phaser.Game(config);

    let player = {
        x: 100,
        y: 100,
        rect: new Phaser.Geom.Rectangle(0, 0, 0, 0),
        graphics: undefined,
        pdx: 0.0,
        pdy: 0.0,
        pa: 3 * Math.PI / 2,
        directionLine: new Phaser.Geom.Line(0, 0, 0, 0),
        directionGraphics: undefined,
    };

    let keyW;
    let keyA;
    let keyS;
    let keyD;

    let mapX = 8;
    let mapY = 8;
    let mapS = 64;

    let map = [
        1, 1, 1, 1, 1, 1, 1, 1,
        1, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 1, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 1,
        1, 0, 0, 0, 0, 2, 0, 1,
        1, 0, 0, 0, 0, 0, 0, 1,
        1, 1, 1, 1, 1, 1, 1, 1,
    ];

    const rayNumber = 60;
    const rayLines = [];
    let lineGraphic;

    const map3d = [];
    let mapGraphic;

    const DR = 0.0174533;

    const sprites = [];
    const rayDistances = new Array(rayNumber);
    const rayHitPoints = new Array(rayNumber);

    function drawPlayer(game) {
        player.rect.setTo(player.x, player.y, 10, 10);
        player.graphics.fillRectShape(player.rect);

        player.directionLine.setTo(player.x + 5, player.y + 5, player.x + player.pdx * 5, player.y + player.pdy * 5);
        player.directionGraphics.strokeLineShape(player.directionLine);
    }

    function clearPlayer() {
        player.graphics.clear();
        player.directionGraphics.clear();
    }

    function draw2DMap(game) {
        for(let i = 0; i < mapY; i++) {
            for(let j = 0; j < mapX; j++) {
                let rect = new Phaser.Geom.Rectangle(j * mapS, i * mapS, mapS-1, mapS-1);
                let graphics = game.add.graphics({ fillStyle: { color: map[i * mapX + j] === 1 ? 0xffffff : 0x000000 } });
                graphics.fillRectShape(rect);
            }
        }
    }

    function movePlayer(game) {
        if (keyW.isDown) {
          
            let tempX = player.x + player.pdx;
            let tempY = player.y + player.pdy;

            if(!isColliding(tempX, tempY)) { 
                player.x = tempX;
                player.y = tempY;
            }

        } else if (keyA.isDown) {
            player.pa -= 0.1;
            if(player.pa < 0)
                player.pa += 2 * Math.PI;
            player.pdx = Math.cos(player.pa) * 5;
            player.pdy = Math.sin(player.pa) * 5;
        } else if (keyS.isDown) {

            let tempX = player.x - player.pdx;
            let tempY = player.y - player.pdy;

            if(!isColliding(tempX, tempY)) { 
                player.x = tempX;
                player.y = tempY;
            }

        } else if (keyD.isDown) {
            player.pa += 0.1;
            if(player.pa > 2 * Math.PI)
               player.pa -= 2 * Math.PI;
            player.pdx = Math.cos(player.pa) * 5;
            player.pdy = Math.sin(player.pa) * 5;
        }

        clearPlayer();
        drawPlayer(game);
    }

    function drawRays3D(game) {
        let r = 0;
        let mx = 0;
        let my = 0;
        let mp = 0;
        let dof = 0;
        let rx = 0.0;
        let ry = 0.0;
        let xo = 0;
        let yo = 0;

        let disT;

        let hmp, vmp, vtype, htype, type;

        let ra = player.pa - DR * 30;
        if(ra < 0)
            ra += 2 * Math.PI; 
        else if (ra > 2 * Math.PI) {
            ra -= 2 * Math.PI;
        }
 
        for(let i = 0; i < 60; i++) {

            // Check Horizontal Lines
            dof = 0;

            let disH = Infinity;
            let hx = player.x;
            let hy = player.y;

            let aTan = -1/Math.tan(ra);
   
            if(ra > Math.PI) { //looking up    
                ry = ((Math.trunc(player.y) >> 6) << 6) - 0.0001;
                rx = (player.y - ry) * aTan + player.x;
                yo = -64;
                xo = -yo * aTan;
            }
            else if(ra < Math.PI) { //looking down
                ry = ((Math.trunc(player.y) >> 6) << 6) + 64;
                rx = (player.y - ry) * aTan + player.x;
                yo = 64;
                xo = -yo * aTan;
            }
            else { // looking straight left or right 
          
                rx = player.x;
                ry = player.y;
                dof = 8;
            }
            while(dof < 8) {
                mx = Math.trunc(rx) >> 6; 
                my = Math.trunc(ry) >> 6;
                mp = my * mapX + mx;
                if(mp > 0 && mp < mapX*mapY && map[mp] != 0) { // hit wall
                    dof = 8;
                    hx = rx;
                    hy = ry;
                    disH = dist(player.x, player.y, hx, hy, ra);
                    hmp = mp; 
                    htype = map[mp];
                } else { // next line
                    rx += xo;
                    ry += yo;
                    dof += 1;
                }
            }

           //Check vertical lines

            let disV = Infinity;
            let vx = player.x;
            let vy = player.y;
            
            const P2 = Math.PI / 2;
            const P3 = 3 * Math.PI / 2; 

            dof = 0;
            let nTan = -Math.tan(ra);
   
            if(ra > P2 && ra < P3) { //looking left
            
                rx = ((Math.trunc(player.x) >> 6) << 6) - 0.0001;
                ry = (player.x - rx) * nTan + player.y;
                xo = -64;
                yo = -xo * nTan;
            }
            else if(ra < P2 || ra > P3) { //looking right
          
                rx = ((Math.trunc(player.x) >> 6) << 6) + 64;
                ry = (player.x - rx) * nTan + player.y;
                xo = 64;
                yo = -xo * nTan;
            }
            else { // looking straight up or down 
          
                rx = player.x;
                ry = player.y;
                dof = 8;
            }
            while(dof < 8) {
                mx = Math.trunc(rx) >> 6; 
                my = Math.trunc(ry) >> 6;
                mp = my * mapX + mx;
                if(mp > 0 && mp < mapX*mapY && map[mp] != 0) { // hit wall
                    dof = 8;
                    vx = rx;
                    vy = ry;
                    disV = dist(player.x, player.y, vx, vy, ra);
                    vmp = mp; 
                    vtype = map[mp];
                } else { // next line
                    rx += xo;
                    ry += yo;
                    dof += 1;
                }
            }

            let wallColor = undefined; 

            let vertical = false;
            if(disV < disH) {
                rx = vx;
                ry = vy;
                disT = disV;
                wallColor = 0xebc634;
                mp = vmp;
                vertical = true;
                type = vtype;
            } else {
                rx = hx;
                ry = hy;
                disT = disH;
                wallColor = 0xffff00;
                mp = hmp;
                vertical = false;
                type = htype;
            }
            
            rayDistances[i] = disT;
            rayHitPoints[i] = {'x': rx, 'y': ry};

            updateRayLine(i, player.x + 5, player.y + 5, rx, ry);


            // 3d walls
            let ca = player.pa - ra;
            if(ca < 0)
                ca += 2 * Math.PI;
            if(ca > 2 * Math.PI)
                ca -= 2 * Math.PI;
            disT = disT * Math.cos(ca); // fix fisheye

            let lineH = (mapS * 320)/disT;
            if(lineH > 320)
                line = 320;

            let lineO = 160 - lineH / 2;

            updateMap3d(i, i * 8 + 530, lineO, i * 8 + 530, lineH + lineO, rx, ry, vertical, type);

            ra += DR;
            if(ra < 0)
                ra += 2 * Math.PI; 
            else if (ra > 2 * Math.PI) {
                ra -= 2 * Math.PI;
            }
            
        }
        updateRayLineGraphics();
        updateMap3dGraphics();
    }

    function clearRays() {
        for( {graphics, line} of rayLines) {
            graphics.clear();
        }
        rayLines.length = 0;
    }

    function clearMap3d() {
        for( {graphics, line} of map3d) {
            graphics.clear();
        }
        map3d.length = 0;
    }

    function dist(ax, ay, bx, by, ang) {
        return Math.sqrt((bx-ax) * (bx-ax) + (by-ay) * (by-ay));
    }

    function initRayLines(game) {
        lineGraphic = game.add.graphics({ lineStyle: { width: 1, color: 0xff00ff} });
        for(let i = 0; i < rayNumber; i++) {
            let line = new Phaser.Geom.Line(0 , 0, 0, 0);
            lineGraphic.strokeLineShape(line);
            rayLines.push(line);
        }

    }

    function updateRayLine(index, x1, y1, x2, y2) {
        rayLines[index].setTo(x1, y1, x2, y2);
    }

    function updateRayLineGraphics() {
        lineGraphic.clear();
        for(let i = 0; i < rayNumber; i++) {
            lineGraphic.strokeLineShape(rayLines[i]);
        }
    }

    function initMap3d(game) {
        mapGraphic = game.add.graphics({ lineStyle: { width: 8, color: 0xffff00 } });
        for(let i = 0; i < rayNumber; i++) {
            let line = new Phaser.Geom.Line(0, 0, 0, 0);
            mapGraphic.strokeLineShape(line);
            map3d.push({line, n: 0});
        }
    }

    function updateMap3d(index, x1, y1, x2, y2, rx, ry, vertical, type) {
        map3d[index].line.setTo(x1, y1, x2, y2);
        map3d[index].rx = rx;
        map3d[index].ry = ry;
        map3d[index].vertical = vertical;
        map3d[index].type = type;
    }

    function updateMap3dGraphics() {
        mapGraphic.clear();

        const test = []
/*
        let lastN = 0;
        let n = 0;

        const sections = {}; 


        for(let i = 0; i < rayNumber; i++) {
        
            let currentN = map3d[i].n;

            console.log( map3d[i]);

            if(currentN != lastN) {
                lastN = currentN;
                n = 0;
                sections[currentN] = 1;
            } else {
                sections[currentN] = sections[currentN] + 1
            }

        }
      
        lastN = 0;
        n = 0;
        
*/
        for(let i = 0; i < rayNumber; i++) {
            //mapGraphic.strokeLineShape(map3d[i]);
            const line = map3d[i].line;

            const rr =  map3d[i].vertical ? map3d[i].ry : map3d[i].rx;

            const position =  Math.ceil(rr - (rr >> 6) * mapS) - 1;
                      
         

            var x = line.x1;
            var lineSize = Math.abs(line.y1 - line.y2);
    
    /*
            if(currentN != lastN) {
                lastN = currentN;
                n = 0;
            } 
*/

            //const indexes = takeSpreadIndexes(64, sections[currentN]);
     
            let pixels;

            if(map3d[i].type === 1) {
                pixels = pixelInfo.get('wall').pixels[position];
            } else {
                pixels = pixelInfo.get('tile_grass_1').pixels[position];
            }

            //var iv = imageTest.pixels[position];
         
        //    n++;

            const ready = takeSpread(pixels, lineSize/8); 

            
        
            let g = 0;

            for(let y = line.y1; y < line.y2; y += 8) {
                let color = map3d[i].vertical ? (ready[g] >> 1) & 8355711 : ready[g];
               
                mapGraphic.fillStyle(color);
                mapGraphic.fillRect(x, y, 8, 8);
                g++;
            }

     
        }
       
    }

    function isColliding(x, y) {

        const mx = ((Math.trunc(x + 5) >> 6) );
        const my = ((Math.trunc(y + 5) >> 6) );
        const mp = my * mapX + mx;

        return map[mp] != 0 

    }

    function loadPixelInfo(game, textureNames) {

        const pixelMap = new Map();

        for(name of textureNames) {

            var src = game.textures.get(name).getSourceImage();

            var canvas = game.textures.createCanvas(`${name}-map`, src.width, src.height).draw(0, 0, src);

            //  You can now access the CanvasTexture properties, such as canvas.imageData

            //  Here we'll just create a rectangle for each pixel, with a unique size

            var pixel = new Phaser.Display.Color();

            var pixelList = []

            for (var x = 0; x < src.width; x++) {
                
                let column = [];

                for (var y = 0; y < src.height; y++) {



                    canvas.getPixel(x, y, pixel);

                    if (pixel.a > 0)
                    {
                        //game.add.rectangle(x * 4, y * 8, 4, 8, pixel.color);
                        column.push(pixel.color);


                    }
                }
                pixelList.push(column);
            }

            pixelMap.set(name, {pixels: pixelList, height: src.height, width: src.width});
        }
        return pixelMap;
        
    }
    
    /*
    def takespread(sequence, num):
    length = float(len(sequence))
    for i in range(num):
        yield sequence[int(ceil(i * length / num))]

*/
    function takeSpread(sequence,  num) {
        const result = []

        const length = sequence.length;
        for(let i = 0; i < num; i++) {
            result.push(sequence[Math.ceil(i * length / num)]);
        }
        return result;
    }

    function takeSpreadIndexes(length, num) {
        const result = [];

        for(let i = 0; i < num; i++) {
            result.push(Math.ceil(i * length / num));
        }

        return result;
    }


    function addSprite(game, x, y) {
        sprites.push({x, y, rect: new Phaser.Geom.Rectangle(0, 0, 0, 0)});
    }

    function renderSprites(game) {
        for(let s of sprites) {
            s.rect.setTo(s.x, s.y, 10, 10);
            player.graphics.fillRectShape(s.rect);
        }   
    }

    function renderSprites3d(game) {
        for(let s of sprites) {
           s.distance = dist(player.x, player.y, s.x, s.y);
        }

        sprites.sort((a,b) => b.distance - a.distance);

        for(let s of sprites) {

            let visible = false;
            let index;

            for(let i = 0; i < rayNumber && !visible; i++) {

                if(rayDistances[i] < s.distance) {
                    continue
                }

                const relativeHitX = rayHitPoints[i].x - player.x;
                const relativeHitY = rayHitPoints[i].y - player.y;

                const m = relativeHitY / relativeHitX;
                const b = relativeHitY - m * relativeHitX;

                //const m = rayHitPoints[i].y - player.y / rayHitPoints[i].x - player.x;
                // b = y - mx
                //const b = rayHitPoints[i].y - m * rayHitPoints[i].x;

                //y = mx + b
               // const tempY = m * s.x + b;
                //console.log(tempY, s.y, m, s.x, b)
                
                //console.log(rayHitPoints[i].x);

                const corners = [
                {x: s.x, y: s.y}, 
                    //                {x: rayHitPoints[i].x, y: rayHitPoints[i].y}, 
                                 /*   {x: rayHitPoints[i].x + 5, y: rayHitPoints[i].y},
                                    {x: rayHitPoints[i].x, y: rayHitPoints[i].y + 5},
                                    {x: rayHitPoints[i].x + 5, y: rayHitPoints[i].y + 5}*/
                                ] 

/*

                const ss = 20;

                for(let i = 0; i <= ss; i++) {
                    corners.push({x: rayHitPoints[i].x + i, y: rayHitPoints[i].y}) // up
                    corners.push({x: rayHitPoints[i].x, y: rayHitPoints[i].y + i}) // left
                    corners.push({x: rayHitPoints[i].x + i, y: rayHitPoints[i].y + ss}) // down
                    corners.push({x: rayHitPoints[i].x + ss, y: rayHitPoints[i].y + i}) // right
                }
  */              

                //for(let c of corners) {
                    if(!visible) {
                        const tempY = (m * (s.x - player.x) + b);
                        visible = Math.abs( Math.trunc(tempY) - Math.trunc(s.y-player.y)) < 15;
                        if(visible) {

                            let tr = new Phaser.Geom.Rectangle(s.x, tempY + player.y, 10, 10);
                            player.graphics.fillStyle(0x0000ff);
                            player.graphics.fillRectShape(tr);

                            let tl = new Phaser.Geom.Line(0 + player.x, (m * 0 + b) + player.y, s.x, tempY + player.y);
                            player.graphics.lineStyle(5, 0x0000ff);
                            player.graphics.strokeLineShape(tl);

                            index = i;
                            console.log(tempY,  s.y-player.y)
                        }

                                              
                    }
                //}

               // visible = Math.trunc(tempY) === Math.trunc(s.y);
                

            }

            if(visible) {
                console.log('visible',s);

                const line = map3d[index].line;

                mapGraphic.fillStyle(0xff00ff);
                mapGraphic.fillRect(line.x1, line.y2 - 10, 20, 20);
            }


        }


    }

    function preload () {

/*
        this.load.image('robot_head_blue', 'assets/sprites/robot_head_blue.png');
        this.load.image('robot_head_green', 'assets/sprites/robot_head_green.png');
        this.load.image('robot_head_yellow', 'assets/sprites/robot_head_yellow.png');
        this.load.image('robot_head_red', 'assets/sprites/robot_head_red.png');

        this.load.image('robot_blue', 'assets/sprites/robot_blue.png');
        this.load.image('robot_green', 'assets/sprites/robot_green.png');
        this.load.image('robot_yellow', 'assets/sprites/robot_yellow.png');
        this.load.image('robot_red', 'assets/sprites/robot_red.png');

        this.load.image('tile_grass_1', 'assets/sprites/tileGrass1.png');
        this.load.image('tile_grass_2', 'assets/sprites/tileGrass2.png');

        this.load.image('pause', 'assets/sprites/pause.png');
        this.load.image('red', 'assets/sprites/red.png');
*/
        this.load.image('tile_grass_1', 'assets/sprites/tileGrass1.png');
        this.load.image('wall', 'assets/sprites/pattern112.png');
        this.load.image('zombie_1', 'assets/sprites/zombie_1.png');

    }

    let pixelInfo;

    function create () {
        draw2DMap(this);

        this.cameras.main.backgroundColor.setTo(75,75,75);

        initRayLines(this);
        initMap3d(this);

        keyW = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W);
        keyA = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A);
        keyS = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S);
        keyD = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D);

        player.pdx = Math.cos(player.pa) * 5;
        player.pdy = Math.sin(player.pa) * 5;

        player.graphics = this.add.graphics({ fillStyle: { color: 0xff0000 } });
        player.directionGraphics = this.add.graphics({ lineStyle: { width: 3, color: 0xaa00aa } });
        drawPlayer(this, 100, 100);

        pixelInfo = loadPixelInfo(game, ['wall', 'tile_grass_1', 'zombie_1']);

        addSprite(this, 300, 200);
        //addSprite(this, 200, 200);
        //addSprite(this, 300, 300);

        this.input.on('pointerdown', function (pointer) {
            this.input.mouse.requestPointerLock();
        }, this);

        this.input.keyboard.on('keydown-Q', function (event) {
            if (this.input.mouse.locked)
            {
                this.input.mouse.releasePointerLock();
            }
        }, this);

        this.input.on('pointermove', function (pointer) {

                if (this.input.mouse.locked)
                {
                    if(pointer.movementX > 0) {
                        player.pa += (0.01 * pointer.movementX);
                        if(player.pa > 2 * Math.PI)
                            player.pa -= 2 * Math.PI;
                        player.pdx = Math.cos(player.pa) * 5;
                        player.pdy = Math.sin(player.pa) * 5;

                    } else {
                        player.pa += (0.01 * pointer.movementX);
                        if(player.pa < 0)
                            player.pa += 2 * Math.PI;
                        player.pdx = Math.cos(player.pa) * 5;
                        player.pdy = Math.sin(player.pa) * 5;
                    }
            
                }
                }, this);
        }

    function update() {
      
        movePlayer(this);
        drawRays3D(this);
        renderSprites(this);
        renderSprites3d(this);
       
    }

    </script>

</body>
</html>